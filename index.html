<html>
    <head>
        <title>is generator function</title>
    </head>
    <body>
        <script type="text/javascript">
            var toStr = Object.prototype.toString;
            var fnToStr = Function.prototype.toString;
            var isFnRegex = /^\s*(?:function)?\*/;

            
            var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
            var getProto = Object.getPrototypeOf;
            var getGeneratorFunc = function () { // eslint-disable-line consistent-return
                if (!hasToStringTag) {
                    return false;
                }
                try {
                    return Function('return function*() {}')();
                } catch (e) {
                }
            };

            var generatorFunc = getGeneratorFunc();
            var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};

            function isGeneratorFunction(fn) {
                if (typeof fn !== 'function') {
                    return false;
                }
                if (isFnRegex.test(fnToStr.call(fn))) {
                    return true;
                }
                if (!hasToStringTag) {
                    var str = toStr.call(fn);
                    return str === '[object GeneratorFunction]';
                }
                return getProto(fn) === GeneratorFunction;
            };


            var a = function*() {};
            var b = function*() {};
            console.log( getProto(a) === getProto(b))



            //koa-compose ==========================

    /**
     * Compose `middleware` returning
     * a fully valid middleware comprised（组成，构成，由...组成）
     * of all those which are passed.
     *
     * @param {Array} middleware
     * @return {Function}
     * @api public
     */


        function compose (middleware) {
            /**
             * @param {Object} context
             * @return {Promise}
             * @api public
             */
            return function (context, next) {
                // last called middleware #
                let index = -1  //上次调用的中间件下标
                return dispatch(0)
                function dispatch (i) {
                    // if (i <= index) return Promise.reject(new Error('next() called multiple times'))
                    // index = i
                    let fn = middleware[i]
                    // 如果 最后一个中间件调用了next方法 ，那使用默认的next;
                    if (i === middleware.length) fn = next
                    if (!fn) return Promise.resolve()
                    try {
                        // 每个中间件 接受上下文context和 下一个中间件的执行结果作为参数
                        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
                    } catch (err) {
                        return Promise.reject(err)
                    }
                }
            }
        }
        </script>
    </body>
</html>